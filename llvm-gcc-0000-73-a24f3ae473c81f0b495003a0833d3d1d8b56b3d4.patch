# HG changeset patch
# User David Meyer <pdox@google.com>
# Date 1296781597 28800
# Branch pnacl-sfi
# Node ID a24f3ae473c81f0b495003a0833d3d1d8b56b3d4
# Parent 037e5342ba867f8a0e180ef4b88e4a4f55d2a999
# Parent  7bb94b24cbbe4933a6ed2e55f902d278bc92cf81
Merged up to r124151

 From llvm-gcc-0000-73-a24f3ae473c81f0b495003a0833d3d1d8b56b3d4.patch

diff -r 037e5342ba86 configure
--- a/configure	Thu Jan 27 21:38:44 2011 +0000
+++ b/configure	Mon Jul 18 18:48:47 2011 -0700
@@ -2681,6 +2681,14 @@
 # $build_configdirs and $target_configdirs.
 # If we have the source for $noconfigdirs entries, add them to $notsupp.
 
+# @LOCALMOD-START disable a bunch of libs we do not want for pnacl
+# we either do not need them or we build them as bitcode in a separate step
+#
+# There seems to be no good way to avoid building them in a less invasive
+# fashion, e.g. configure args or makefile targets
+noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3"
+# @LOCALMOD-STOP
+
 notsupp=""
 for dir in . $skipdirs $noconfigdirs ; do
   dirname=`echo $dir | sed -e s/target-//g -e s/build-//g`
diff -r 037e5342ba86 gcc/Makefile.in
--- a/gcc/Makefile.in	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/Makefile.in	Mon Jul 18 18:48:47 2011 -0700
@@ -1684,7 +1684,7 @@
 #
 # Build libgcc.a.
 
-LIB2ADD = $(LIB2FUNCS_EXTRA)
+LIB2ADD = $(LIB2FUNCS_EXTRA) $(srcdir)/libgcc-memcpy.c
 LIB2ADD_ST = $(LIB2FUNCS_STATIC_EXTRA)
 
 # LLVM LOCAL begin libcc_kext
diff -r 037e5342ba86 gcc/builtins.c
--- a/gcc/builtins.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/builtins.c	Mon Jul 18 18:48:47 2011 -0700
@@ -4359,6 +4359,30 @@
   return build_va_arg_indirect_ref (addr);
 }
 
+/* Use the LLVM implementation of va_arg: turn __builtin_va_arg, aka
+   VA_ARG_EXPR, into a call to BUILT_IN_VA_ARG, which will later get
+   lowered into the LLVM va_arg instruction. */
+tree
+llvm_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)
+{
+  tree expr;
+
+  /* if the tree code is an ARRAY_TYPE, gimplify_va_arg_expr has already
+     taken the address before calling us. */
+  if (TREE_CODE (va_list_type_node) != ARRAY_TYPE)
+    /* Take the address: despite the syntax, the va_list is really being
+       passed by reference with the intent of modification. */
+    valist = build1 (ADDR_EXPR,
+		     build_pointer_type (TREE_TYPE (valist)),
+		     valist);
+
+  valist = tree_cons (NULL_TREE, valist, NULL_TREE);
+  expr = build_function_call_expr (
+      implicit_built_in_decls[BUILT_IN_VA_ARG], valist);
+  TREE_TYPE(expr) = type;
+  return expr;
+}
+
 /* Build an indirect-ref expression over the given TREE, which represents a
    piece of a va_arg() expansion.  */
 tree
@@ -4476,7 +4500,13 @@
 	   assert this is non-null.  */
 	return GS_ALL_DONE;
 
-      *expr_p = targetm.gimplify_va_arg_expr (valist, type, pre_p, post_p);
+      if (flag_use_llvm_va_arg)
+        /* -fuse-llvm-va-arg was specified. Don't expand the VA_ARG
+           operator, but turn it into an LLVM VAArgInst */
+        *expr_p = llvm_gimplify_va_arg_expr (valist, type, pre_p, post_p);
+      else
+        *expr_p = targetm.gimplify_va_arg_expr (valist, type, pre_p, post_p);
+
       return GS_OK;
     }
 }
diff -r 037e5342ba86 gcc/builtins.def
--- a/gcc/builtins.def	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/builtins.def	Mon Jul 18 18:48:47 2011 -0700
@@ -702,6 +702,14 @@
 DEF_GCC_BUILTIN        (BUILT_IN_VA_COPY, "va_copy", BT_FN_VOID_VALIST_REF_VALIST_ARG, ATTR_NULL)
 DEF_GCC_BUILTIN        (BUILT_IN_VA_END, "va_end", BT_FN_VOID_VALIST_REF, ATTR_NULL)
 DEF_GCC_BUILTIN        (BUILT_IN_VA_START, "va_start", BT_FN_VOID_VALIST_REF_VAR, ATTR_NULL)
+/* NB, the source generates a call to __builtin_va_arg, which corresponds to 
+ * the VA_ARG_EXPR tree operator; we lower this to a call to the function below
+ * which is then lowered to an LLVM opcode.  i.e. the call exists only 
+ * transiently during gimplification and its name is completely arbitrary.
+ * We hackishly store the va_arg macro's type argument in the tree.type field 
+ * of the function call result.
+ */
+DEF_GCC_BUILTIN        (BUILT_IN_VA_ARG, "va_arg", BT_FN_VOID_VALIST_REF_VAR, ATTR_NULL)
 DEF_EXT_LIB_BUILTIN    (BUILT_IN__EXIT, "_exit", BT_FN_VOID_INT, ATTR_NORETURN_NOTHROW_LIST)
 DEF_C99_BUILTIN        (BUILT_IN__EXIT2, "_Exit", BT_FN_VOID_INT, ATTR_NORETURN_NOTHROW_LIST)
 
diff -r 037e5342ba86 gcc/common.opt
--- a/gcc/common.opt	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/common.opt	Mon Jul 18 18:48:47 2011 -0700
@@ -117,6 +117,16 @@
 Common Var(warn_padded)
 Warn when padding is required to align structure members
 
+; LOCALMOD-BEGIN
+Wportable-llvm
+Common Var(warn_portable_llvm)
+Warn if non-portable asm will be emitted into LLVM bitcode
+
+Werror-portable-llvm
+Common Var(error_portable_llvm)
+Treat non-portable asm that will be emitted into LLVM bitcode as errors
+; LOCALMOD-END
+
 Wshadow
 Common Var(warn_shadow)
 Warn when one local variable shadows another
@@ -1252,6 +1262,10 @@
 Enable common options for performing profile feedback directed optimizations
 ; APPLE LOCAL end new profiling flag
 
+fuse-llvm-va-arg
+Common Report Var(flag_use_llvm_va_arg) Init(0)
+Use the LLVM va_arg instruction instead of generating target-dependent code.
+
 fvar-tracking
 Common Report Var(flag_var_tracking) VarExists
 Perform variable tracking
diff -r 037e5342ba86 gcc/config.gcc
--- a/gcc/config.gcc	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config.gcc	Mon Jul 18 18:48:47 2011 -0700
@@ -522,7 +522,7 @@
   ;;
 *-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
   # Must come before *-*-gnu* (because of *-*-linux-gnu* systems).
-  extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+  extra_parts="crtbegin.o crtbeginT.o crtend.o"
   extra_options="${extra_options} linux.opt"
   gas=yes
   gnu_ld=yes
diff -r 037e5342ba86 gcc/config/arm/arm-tune.md
--- a/gcc/config/arm/arm-tune.md	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/arm-tune.md	Mon Jul 18 18:48:47 2011 -0700
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from arm-cores.def
 (define_attr "tune"
-	"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2fs,cortexa9,arm1156t2s,cortexa8,cortexr4,cortexm3"
+	"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,arm1156t2fs,cortexa8,cortexa9,cortexr4,cortexm3,cortexm4,cortexm0"
 	(const (symbol_ref "arm_tune")))
diff -r 037e5342ba86 gcc/config/arm/arm.c
--- a/gcc/config/arm/arm.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/arm.c	Mon Jul 18 18:48:47 2011 -0700
@@ -456,8 +456,25 @@
 #undef TARGET_ASM_TTYPE
 #define TARGET_ASM_TTYPE arm_output_ttype
 
+/* @LOCALMOD-START */
+/* Remove ARM bias in bitcode generated for exception handling 
+ * NOTE: LLVM abstracts away unwind table generation so we can ignore this here
+ * 
+ * The ARM bias mentioned above is reflected by if statements like:
+ *   if (targetm.arm_eabi_unwinder)
+ *
+ * Concretely, in gcc/cp/except.c we now use:
+ * _Unwind_Resume_or_Rethrow instead of  __cxa_end_cleanup 
+ *
+ * Note, We may needs to do something similar for  TARGET_CXX_USE_AEABI_ATEXIT
+ * which controls the use of __aeabi_atexit via targetm.cxx.use_aeabi_atexit
+ */
+/*
 #undef TARGET_ARM_EABI_UNWINDER
 #define TARGET_ARM_EABI_UNWINDER true
+*/
+/* @LOCALMOD-END  */
+
 #endif /* TARGET_UNWIND_INFO */
 
 /* APPLE LOCAL begin v7 support. Merge from mainline */
@@ -23358,6 +23375,16 @@
   if (IS_IWMMXT_REGNUM (regno))
     return 112 + regno - FIRST_IWMMXT_REGNUM;
 
+  /* @LOCALMOD-START */
+  /* this is a horrible hack and we only ever get here when processing the
+   * built-in __builtin_init_dwarf_reg_size_table within libgcc_eh 
+   * which is processed by c.f. TreeToLLVM::EmitBuiltinInitDwarfRegSizes()
+   * 
+   * using PSEUDO_REGISTER - 1 is safe as we only care about the first 16 regs
+   * anyway 
+   */
+  return FIRST_PSEUDO_REGISTER - 1;
+  /* @LOCALMOD-END */
   gcc_unreachable ();
 }
 
diff -r 037e5342ba86 gcc/config/arm/arm.h
--- a/gcc/config/arm/arm.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/arm.h	Mon Jul 18 18:48:47 2011 -0700
@@ -402,6 +402,9 @@
 
 extern enum float_abi_type arm_float_abi;
 
+/* @LOCALMOD-BEGIN */
+#define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_HARD
+/* @LOCALMOD-END */
 #ifndef TARGET_DEFAULT_FLOAT_ABI
 #define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFT
 #endif
@@ -694,6 +697,18 @@
 #endif
 
 
+
+/* @LOCALMOD-START */
+/*
+ * This macro specifies the maximum number of hard registers that
+ * can be saved in a call frame
+ * NOTE: this needs some more investigation but enables us to build libgcc_eh
+ * for ARM
+ *
+ */
+#define DWARF_FRAME_REGISTERS 16
+/* @LOCALMOD-END */
+
 /* Standard register usage.  */
 
 /* Register allocation in ARM Procedure Call Standard (as used on RISCiX):
diff -r 037e5342ba86 gcc/config/arm/bpabi.S
--- a/gcc/config/arm/bpabi.S	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/bpabi.S	Mon Jul 18 18:48:47 2011 -0700
@@ -81,7 +81,7 @@
 #ifdef L_aeabi_ldivmod
 
 ARM_FUNC_START aeabi_ldivmod
-	sub sp, sp, #8
+	sfi_sub sp, sp, #8
 /* APPLE LOCAL begin v7 support. Merge from mainline */
 #if defined(__thumb2__)
 	mov ip, sp
@@ -89,9 +89,10 @@
 #else
 	do_push {sp, lr}
 #endif
+	sfi_call_preamble
 	bl SYM(__gnu_ldivmod_helper) __PLT__
 	ldr lr, [sp, #4]
-	add sp, sp, #8
+	sfi_add sp, sp, #8
 	do_pop {r2, r3}
 /* APPLE LOCAL end v7 support. Merge from mainline */
 	RET
@@ -101,7 +102,7 @@
 #ifdef L_aeabi_uldivmod
 
 ARM_FUNC_START aeabi_uldivmod
-	sub sp, sp, #8
+	sfi_sub sp, sp, #8
 /* APPLE LOCAL begin v7 support. Merge from mainline */
 #if defined(__thumb2__)
 	mov ip, sp
@@ -109,9 +110,10 @@
 #else
 	do_push {sp, lr}
 #endif
+	sfi_call_preamble
 	bl SYM(__gnu_uldivmod_helper) __PLT__
 	ldr lr, [sp, #4]
-	add sp, sp, #8
+	sfi_add sp, sp, #8
 	do_pop {r2, r3}
 /* APPLE LOCAL end v7 support. Merge from mainline */
 	RET
diff -r 037e5342ba86 gcc/config/arm/bpabi.h
--- a/gcc/config/arm/bpabi.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/bpabi.h	Mon Jul 18 18:48:47 2011 -0700
@@ -66,12 +66,20 @@
 #define RENAME_LIBRARY_SET ".set"
 #endif
 
+/* @LOCALMOD-START
+ * use a non-asm mechanism for creating function aliases 
+ */
+#if 1 
+#define RENAME_LIBRARY(GCC_NAME, AEABI_NAME) \
+  void __aeabi_  ## AEABI_NAME () __attribute__ ((alias ( "__" #GCC_NAME)));	
+#else
+/* @LOCALMOD-END */
 /* Make __aeabi_AEABI_NAME an alias for __GCC_NAME.  */
 #define RENAME_LIBRARY(GCC_NAME, AEABI_NAME)		\
   __asm__ (".globl\t__aeabi_" #AEABI_NAME "\n"		\
 	   RENAME_LIBRARY_SET "\t__aeabi_" #AEABI_NAME 	\
 	     ", __" #GCC_NAME "\n");
-
+#endif /* @LOCAMOD */
 /* Give some libgcc functions an additional __aeabi name.  */
 #ifdef L_muldi3
 #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (muldi3, lmul)
diff -r 037e5342ba86 gcc/config/arm/lib1funcs.asm
--- a/gcc/config/arm/lib1funcs.asm	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/lib1funcs.asm	Mon Jul 18 18:48:47 2011 -0700
@@ -32,6 +32,9 @@
 
 /* We need to know what prefix to add to function names.  */
 
+/* @LOCALMOD: This must be the first thing in the file */
+#include "naclmacros.asm"
+
 #ifndef __USER_LABEL_PREFIX__
 #error  __USER_LABEL_PREFIX__ not defined
 #endif
@@ -97,8 +100,8 @@
 
 #if (__ARM_ARCH__ > 4) || defined(__ARM_ARCH_4T__)
 
-# define RET		bx	lr
-# define RETc(x)	bx##x	lr
+# define RET		sfi_bx	lr
+# define RETc(x)	sfi_bx##x	lr
 
 /* Special precautions for interworking on armv4t.  */
 # if (__ARM_ARCH__ == 4)
@@ -116,7 +119,7 @@
 #endif /* __ARM_ARCH == 4 */
 
 #else
-
+/* LOCALMOD we do not support ARCH 4 in NaCl, no changes here. */
 # define RET		mov	pc, lr
 # define RETc(x)	mov##x	pc, lr
 
@@ -210,22 +213,28 @@
 	bx	lr
 #else
 #define RETLDM \
-	ldr     pc, [sp], #8
+	ldr     lr, [sp], #8
+  sfi_bx  lr
 /* APPLE LOCAL begin v7 support. Merge from mainline */
 #if defined (__thumb2__)
 #define RETLDM1(...) \
-	pop   {__VA_ARGS__, pc}
+	pop   {__VA_ARGS__, lr}
+  sfi_bx lr
 #define RETLDM2(cond,...) \
-	pop##cond   {__VA_ARGS__, pc}
+	pop##cond   {__VA_ARGS__, lr}
+  sfi_bx lr
 #else
 #define RETLDM1(...) \
-	ldmia   sp!, {__VA_ARGS__, pc}
+	ldmia   sp!, {__VA_ARGS__, lr}
+  sfi_bx lr
 #define RETLDM2(cond,...) \
-	ldm##cond##ia   sp!, {__VA_ARGS__, pc}
+	ldm##cond##ia   sp!, {__VA_ARGS__, lr}
+  sfi_bx lr
 #endif
 /* APPLE LOCAL end v7 support. Merge from mainline */
 #define RETLDM_unwind(addr) \
-	ldr	pc, [sp], #8
+	ldr	lr, [sp], #8
+  sfi_bx lr
 #endif
 
 /* APPLE LOCAL begin v7 support. Merge from mainline */
@@ -292,6 +301,7 @@
 #if !defined(__MACH__)
 98:	cfi_push 98b - __\name, 0xe, -0x8, 0x8
 #endif
+  sfi_call_preamble
 	bl	SYM (__div0) __PLT__
 	mov	r0, #0			@ About as wrong as it could be.
 	RETLDM_unwind (8b)
@@ -303,13 +313,15 @@
 #if !defined(__MACH__)
 7:	cfi_push 7b - __\name, 0xe, -0x4, 0x8
 #endif
+  sfi_call_preamble
 	bl	SYM (__div0)
 	mov	r0, #0			@ About as wrong as it could be.
 #if defined (__INTERWORKING__)
 	pop	{ r1, r2 }
 	bx	r2
 #else
-	pop	{ r1, pc }
+	pop	{ r1, lr }
+  sfi_bx lr
 #endif
 .endm
 
@@ -372,7 +384,7 @@
 #define THUMB_FUNC
 #define THUMB_CODE
 /* APPLE LOCAL ARM function alignment */
-#define FUNC_ALIGN .align 2
+#define FUNC_ALIGN .align 4
 /* APPLE LOCAL v7 support. Merge from mainline */
 #define THUMB_SYNTAX
 #endif
@@ -391,7 +403,7 @@
 	.text
 	.globl SYM (__\name)
 	TYPE (__\name)
-	.align 0
+	.align 4
 	THUMB_CODE
 	THUMB_FUNC
 SYM (__\name):
@@ -418,6 +430,7 @@
 #if defined(__MACH__)
   bl ___$0
 #else
+  sfi_call_preamble
   bl  ___\name
 #endif
 .endm
@@ -471,7 +484,7 @@
 	.text
 	.globl SYM (__\name)
 	TYPE (__\name)
-	.align 0
+	.align 4
 	.arm
 SYM (__\name):
 #endif
@@ -481,6 +494,7 @@
 #if defined(__MACH__)
 	bl	SYM (__$0)
 #else
+  sfi_call_preamble
 	bl	__\name
 #endif
 .endm
@@ -534,16 +548,18 @@
 	.set	shift, shift - 1				; \
 	cmp	dividend, divisor, lsl #shift			; \
 	adc	result, result, result				; \
-	subcs	dividend, dividend, divisor, lsl #shift
+	subcs	dividend, dividend, divisor, lsl #shift  ; \
+  nop
 #define ARM_DIV_BODY(dividend, divisor, result, curbit)	  	  \
 	clz	curbit, dividend				; \
 	clz	result, divisor					; \
 	sub	curbit, result, curbit				; \
 	rsbs	curbit, curbit, #31				; \
-	addne	curbit, curbit, curbit, lsl #1			; \
 	mov	result, #0					; \
-	addne	pc, pc, curbit, lsl #2				; \
-	nop							; \
+  sfi_new_bundle                ; \
+  add curbit, pc, curbit, lsl #4  ; \
+  add curbit, curbit, #8  ; \
+  sfi_bxne curbit         ; \
 	.set	shift, 32					; \
 	ARMV5_DIV_LOOP (dividend, divisor, result)		; \
 	ARMV5_DIV_LOOP (dividend, divisor, result)		; \
@@ -671,14 +687,18 @@
 #define ARMV5_MOD_LOOP(dividend, divisor)			  \
 	.set	shift, shift - 1				; \
 	cmp	dividend, divisor, lsl #shift			; \
-	subcs	dividend, dividend, divisor, lsl #shift
+	subcs	dividend, dividend, divisor, lsl #shift ; \
+  nop ; \
+  nop
 #define ARM_MOD_BODY(dividend, divisor, order, spare)	 	  \
 	clz	order, divisor					; \
 	clz	spare, dividend					; \
 	sub	order, order, spare				; \
 	rsbs	order, order, #31				; \
-	addne	pc, pc, order, lsl #3				; \
-	nop							; \
+  sfi_new_bundle                ; \
+  add spare, pc, order, lsl #4  ; \
+  add spare, spare, #8          ; \
+  sfi_bxne spare                ; \
 	.set	shift, 32					; \
 	ARMV5_MOD_LOOP (dividend, divisor)			; \
 	ARMV5_MOD_LOOP (dividend, divisor)			; \
@@ -1014,6 +1034,7 @@
 	bx	r3
 #else
 	stmfd	sp!, { r0, r1, lr }
+  sfi_call_preamble
 	bl	SYM(__udivsi3)
 	ldmfd	sp!, { r1, r2, lr }
 	mul	r3, r2, r0
@@ -1165,6 +1186,7 @@
 	bx	r3
 #else
 	stmfd	sp!, { r0, r1, lr }
+  sfi_call_preamble
 	bl	SYM(__divsi3)
 	ldmfd	sp!, { r1, r2, lr }
 	mul	r3, r2, r0
@@ -1266,8 +1288,12 @@
 
 	/* LLVM LOCAL mainline */
 	do_push	{r1, lr}
-	mov	r0, #SIGFPE
-	bl	SYM(raise) __PLT__
+#ifdef __native_client__
+	NACL_HALT
+#else
+	mov     r0, #SIGFPE
+	bl      SYM(raise) __PLT__
+#endif
 	/* APPLE LOCAL ARM MACH assembler */
 	RETLDM1 (r1)
 
@@ -1510,6 +1536,7 @@
 		
 /* Do not build the interworking functions when the target architecture does 
    not support Thumb instructions.  (This can be a multilib option).  */
+#if defined(__thumb__)
 #if defined __ARM_ARCH_4T__ || defined __ARM_ARCH_5T__\
       || defined __ARM_ARCH_5TE__ || defined __ARM_ARCH_5TEJ__ \
       || __ARM_ARCH__ >= 6
@@ -1688,6 +1715,7 @@
 /* APPLE LOCAL v7 support. Merge from mainline */
 #endif /* !__thumb2__ */
 #endif /* Arch supports thumb.  */
+#endif /* Thumb is enabled */
 
 #ifndef __symbian__
 #include "ieee754-df.S"
diff -r 037e5342ba86 gcc/config/arm/libunwind.S
--- a/gcc/config/arm/libunwind.S	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/libunwind.S	Mon Jul 18 18:48:47 2011 -0700
@@ -26,6 +26,8 @@
    the Free Software Foundation, 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.  */
 
+#error "@LOCALMOD we do not use arm specific exception handling"
+
 #ifndef __symbian__
 
 #include "lib1funcs.asm"
diff -r 037e5342ba86 gcc/config/arm/linux-eabi.h
--- a/gcc/config/arm/linux-eabi.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/linux-eabi.h	Mon Jul 18 18:48:47 2011 -0700
@@ -33,8 +33,10 @@
 
 /* We default to a soft-float ABI so that binaries can run on all
    target hardware.  */
-#undef TARGET_DEFAULT_FLOAT_ABI
-#define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFT
+// @LOCALMOD
+// #undef TARGET_DEFAULT_FLOAT_ABI
+// #define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFT
+#define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_HARD
 
 /* We default to the "aapcs-linux" ABI so that enums are int-sized by
    default.  */
diff -r 037e5342ba86 gcc/config/arm/llvm-arm-target.h
--- a/gcc/config/arm/llvm-arm-target.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/llvm-arm-target.h	Mon Jul 18 18:48:47 2011 -0700
@@ -102,6 +102,27 @@
 #define LLVM_SHOULD_RETURN_VECTOR_AS_SHADOW(X, isBuiltin) \
   (TREE_INT_CST_LOW(TYPE_SIZE(X)) > 128)
 
+
+/* @LOCALMOD-START */
+/* do not do anything special for arm use defaults from: gcc/llvm-abi.h */
+#undef LLVM_SHOULD_PASS_AGGREGATE_IN_MIXED_REGS
+#undef LLVM_TRY_PASS_AGGREGATE_CUSTOM
+#undef LLVM_AGGREGATE_PARTIALLY_PASSED_IN_REGS
+#undef LLVM_AGGR_TYPE_FOR_STRUCT_RETURN
+#undef LLVM_EXTRACT_MULTIPLE_RETURN_VALUE
+#undef LLVM_SHOULD_NOT_USE_SHADOW_RETURN
+#undef LLVM_SHOULD_RETURN_VECTOR_AS_SHADOW
+/* overwrite these defaults to not pass aggregates in regs */
+#define LLVM_SHOULD_PASS_AGGREGATE_AS_FCA(X, TY) true
+#define LLVM_SHOULD_PASS_AGGREGATE_IN_INTEGER_REGS(X, Y, Z) false
+/* force default calling convention */
+#undef TARGET_ADJUST_LLVM_CC
+#define TARGET_ADJUST_LLVM_CC(CC, type)           \
+  {                                               \
+        CC = CallingConv::C;                      \
+  }
+
+/* @LOCALMOD-END */
 #endif /* LLVM_ABI_H */
 #endif /* ENABLE_LLVM */
 /* LLVM LOCAL end (ENTIRE FILE!)  */
diff -r 037e5342ba86 gcc/config/arm/naclmacros.asm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gcc/config/arm/naclmacros.asm	Mon Jul 18 18:48:47 2011 -0700
@@ -0,0 +1,392 @@
+@LOCALMOD_START - NativeClient SFI macros
+  .macro sfi_long_based_on_pos p0 p1 p2 p3 val
+	.set pos, (. - XmagicX) % 16
+	.fill  (((\p3<<12)|(\p2<<8)|(\p1<<4)|\p0)>>pos) & 15, 4, \val
+	.endm
+
+
+  .macro sfi_new_bundle
+  .align 4
+  .endm
+
+	.macro sfi_illegal_if_at_bundle_begining
+	sfi_long_based_on_pos 1 0 0 0 0xe1277777
+	.endm
+
+
+	.macro sfi_nop_if_at_bundle_end
+	sfi_long_based_on_pos 0 0 0 1 0xe1a00000
+	.endm
+
+
+	.macro sfi_nops_to_force_slot3
+	sfi_long_based_on_pos 3 2 1 0 0xe1a00000
+	.endm
+
+
+	.macro sfi_nops_to_force_slot2
+	sfi_long_based_on_pos 2 1 0 3 0xe1a00000
+	.endm
+
+
+	.macro sfi_nops_to_force_slot1
+	sfi_long_based_on_pos 1 0 3 2 0xe1a00000
+	.endm
+
+
+ @ ========================================
+	.macro sfi_data_mask reg cond
+	bic\cond \reg, \reg, #0xc0000000
+	.endm
+
+
+	.macro sfi_code_mask reg cond=
+	bic\cond \reg, \reg, #0xc000000f
+	.endm
+
+
+ @ ========================================
+	.macro sfi_call_preamble
+	sfi_nops_to_force_slot3
+	.endm
+
+
+	.macro sfi_return_alignment_and_code_mask reg cond=
+	sfi_nop_if_at_bundle_end
+	sfi_code_mask \reg \cond
+	.endm
+
+
+ @ ========================================
+	.macro sfi_store_preamble reg cond
+	.if \reg != sp
+	sfi_nop_if_at_bundle_end
+	sfi_data_mask \reg, \cond
+	.endif
+	.endm
+
+
+ @ ========================================
+	.macro sfi_add rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	add \rega, \regb, \imm, \rot
+	sfi_data_mask \rega
+	.endm
+
+
+	.macro sfi_addeq rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addeq \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, eq
+	.endm
+
+
+	.macro sfi_addne rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addne \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ne
+	.endm
+
+
+	.macro sfi_addlt rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addlt \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, lt
+	.endm
+
+
+	.macro sfi_addle rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addle \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, le
+	.endm
+
+
+	.macro sfi_addls rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addls \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ls
+	.endm
+
+
+	.macro sfi_addge rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addge \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ge
+	.endm
+
+
+	.macro sfi_addgt rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addgt \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, gt
+	.endm
+
+
+	.macro sfi_addhs rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addhs \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, hs
+	.endm
+
+
+	.macro sfi_addhi rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addhi \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, hi
+	.endm
+
+
+	.macro sfi_addlo rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	addlo \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, lo
+	.endm
+
+
+ @ ========================================
+	.macro sfi_sub rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	sub \rega, \regb, \imm, \rot
+	sfi_data_mask \rega
+	.endm
+
+
+	.macro sfi_subeq rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	subeq \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, eq
+	.endm
+
+
+	.macro sfi_subne rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	subne \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ne
+	.endm
+
+
+	.macro sfi_sublt rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	sublt \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, lt
+	.endm
+
+
+	.macro sfi_suble rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	suble \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, le
+	.endm
+
+
+	.macro sfi_subls rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	subls \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ls
+	.endm
+
+
+	.macro sfi_subge rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	subge \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ge
+	.endm
+
+
+	.macro sfi_subgt rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	subgt \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, gt
+	.endm
+
+
+	.macro sfi_subhs rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	subhs \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, hs
+	.endm
+
+
+	.macro sfi_subhi rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	subhi \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, hi
+	.endm
+
+
+	.macro sfi_sublo rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	sublo \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, lo
+	.endm
+
+
+ @ ========================================
+	.macro sfi_mov rega regb
+	sfi_nop_if_at_bundle_end
+	mov \rega, \regb
+	sfi_data_mask \rega
+	.endm
+
+
+	.macro mov_subeq rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	moveq \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, eq
+	.endm
+
+
+	.macro mov_subne rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movne \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ne
+	.endm
+
+
+	.macro mov_sublt rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movlt \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, lt
+	.endm
+
+
+	.macro mov_suble rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movle \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, le
+	.endm
+
+
+	.macro mov_subls rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movls \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ls
+	.endm
+
+
+	.macro mov_subge rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movge \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, ge
+	.endm
+
+
+	.macro mov_subgt rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movgt \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, gt
+	.endm
+
+
+	.macro mov_subhs rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movhs \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, hs
+	.endm
+
+
+	.macro mov_subhi rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movhi \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, hi
+	.endm
+
+
+	.macro mov_sublo rega regb imm rot=0
+	sfi_nop_if_at_bundle_end
+	movlo \rega, \regb, \imm, \rot
+	sfi_data_mask \rega, lo
+	.endm
+
+
+ @ ========================================
+	.macro sfi_bx link
+	sfi_return_alignment_and_code_mask \link
+	bx \link
+	.endm
+
+
+	.macro sfi_bxeq link
+	sfi_return_alignment_and_code_mask \link eq
+	bxeq \link
+	.endm
+
+
+	.macro sfi_bxne link
+	sfi_return_alignment_and_code_mask \link ne
+	bxne \link
+	.endm
+
+
+	.macro sfi_bxlt link
+	sfi_return_alignment_and_code_mask \link lt
+	bxlt \link
+	.endm
+
+
+	.macro sfi_bxle link
+	sfi_return_alignment_and_code_mask \link le
+	bxle \link
+	.endm
+
+
+	.macro sfi_bxls link
+	sfi_return_alignment_and_code_mask \link ls
+	bxls \link
+	.endm
+
+
+	.macro sfi_bxge link
+	sfi_return_alignment_and_code_mask \link ge
+	bxge \link
+	.endm
+
+
+	.macro sfi_bxgt link
+	sfi_return_alignment_and_code_mask \link gt
+	bxgt \link
+	.endm
+
+
+	.macro sfi_bxhs link
+	sfi_return_alignment_and_code_mask \link hs
+	bxhs \link
+	.endm
+
+
+	.macro sfi_bxhi link
+	sfi_return_alignment_and_code_mask \link hi
+	bxhi \link
+	.endm
+
+
+	.macro sfi_bxlo link
+	sfi_return_alignment_and_code_mask \link lo
+	bxlo \link
+	.endm
+
+	.macro sfi_bxcc link
+	sfi_return_alignment_and_code_mask \link lo
+	bxcc \link
+	.endm
+
+
+ @ ========================================
+	.macro sfi_indirect_jump_preamble link
+	sfi_nop_if_at_bundle_end
+	sfi_code_mask \link
+	.endm
+
+
+	.macro sfi_indirect_call_preamble link
+	sfi_nops_to_force_slot2
+	sfi_code_mask \link
+  .endm
+@LOCALMOD_END
+
+.align 4
+XmagicX:
+
+#define NACL_HALT         bkpt 0x6666
+
diff -r 037e5342ba86 gcc/config/arm/pr-support.c
--- a/gcc/config/arm/pr-support.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/pr-support.c	Mon Jul 18 18:48:47 2011 -0700
@@ -27,10 +27,7 @@
    Boston, MA 02110-1301, USA.  */
 #include "unwind.h"
 
-/* We add a prototype for abort here to avoid creating a dependency on
-   target headers.  */
-extern void abort (void);
-
+#error "@LOCALMOD we do not use arm specific exception handling"
 typedef struct _ZSt9type_info type_info; /* This names C++ type_info type */
 
 /* Misc constants.  */
diff -r 037e5342ba86 gcc/config/arm/t-bpabi
--- a/gcc/config/arm/t-bpabi	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/t-bpabi	Mon Jul 18 18:48:47 2011 -0700
@@ -4,12 +4,15 @@
 # Add the BPABI C functions.
 LIB2FUNCS_EXTRA = $(srcdir)/config/arm/bpabi.c \
 		  $(srcdir)/config/arm/unaligned-funcs.c
+# @LOCAMOD-START
+# NOTE: disable arm specific exception stuff
+#UNWIND_H = $(srcdir)/config/arm/unwind-arm.h
+#LIB2ADDEH = $(srcdir)/config/arm/unwind-arm.c \
+#  $(srcdir)/config/arm/libunwind.S \
+#  $(srcdir)/config/arm/pr-support.c $(srcdir)/unwind-c.c
+#LIB2ADDEHDEP = $(UNWIND_H) $(srcdir)/config/$(LIB1ASMSRC)
+# @LOCAMOD-END
 
-UNWIND_H = $(srcdir)/config/arm/unwind-arm.h
-LIB2ADDEH = $(srcdir)/config/arm/unwind-arm.c \
-  $(srcdir)/config/arm/libunwind.S \
-  $(srcdir)/config/arm/pr-support.c $(srcdir)/unwind-c.c
-LIB2ADDEHDEP = $(UNWIND_H) $(srcdir)/config/$(LIB1ASMSRC)
 
 # Add the BPABI names.
 SHLIB_MAPFILES += $(srcdir)/config/arm/libgcc-bpabi.ver
diff -r 037e5342ba86 gcc/config/arm/t-symbian
--- a/gcc/config/arm/t-symbian	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/t-symbian	Mon Jul 18 18:48:47 2011 -0700
@@ -13,9 +13,12 @@
 	_fixsfsi _fixunssfsi
 
 # Include the gcc personality routine
-UNWIND_H = $(srcdir)/config/arm/unwind-arm.h
-LIB2ADDEH = $(srcdir)/unwind-c.c $(srcdir)/config/arm/pr-support.c
-LIB2ADDEHDEP = $(UNWIND_H)
+# @LOCAMOD-START
+# NOTE: disable arm specific exception stuff
+#UNWIND_H = $(srcdir)/config/arm/unwind-arm.h
+#LIB2ADDEH = $(srcdir)/unwind-c.c $(srcdir)/config/arm/pr-support.c
+#LIB2ADDEHDEP = $(UNWIND_H)
+# @LOCAMOD-END
 
 # Create a multilib for processors with VFP floating-point, and a
 # multilib for those without -- using the soft-float ABI in both
diff -r 037e5342ba86 gcc/config/arm/unwind-arm.c
--- a/gcc/config/arm/unwind-arm.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/arm/unwind-arm.c	Mon Jul 18 18:48:47 2011 -0700
@@ -27,9 +27,7 @@
    Boston, MA 02110-1301, USA.  */
 #include "unwind.h"
 
-/* We add a prototype for abort here to avoid creating a dependency on
-   target headers.  */
-extern void abort (void);
+#error "@LOCALMOD we do not use arm specific exception handling"
 
 /* Definitions for C++ runtime support routines.  We make these weak
    declarations to avoid pulling in libsupc++ unnecessarily.  */
diff -r 037e5342ba86 gcc/config/i386/i386.h
--- a/gcc/config/i386/i386.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/i386/i386.h	Mon Jul 18 18:48:47 2011 -0700
@@ -621,7 +621,8 @@
 
 /* target machine storage layout */
 
-#define LONG_DOUBLE_TYPE_SIZE 80
+// @LOCALMOD
+#define LONG_DOUBLE_TYPE_SIZE 64
 
 /* Set the value of FLT_EVAL_METHOD in float.h.  When using only the
    FPU, assume that the fpcw is set to extended precision; when using
diff -r 037e5342ba86 gcc/config/i386/llvm-i386.cpp
--- a/gcc/config/i386/llvm-i386.cpp	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/i386/llvm-i386.cpp	Mon Jul 18 18:48:47 2011 -0700
@@ -1746,7 +1746,8 @@
     case X86_64_X87_CLASS:
     case X86_64_X87UP_CLASS:
     case X86_64_COMPLEX_X87_CLASS:
-      Elts.push_back(Type::getX86_FP80Ty(Context));
+      // @LOCALMOD
+      Elts.push_back(Type::getDoubleTy(Context));
       break;
     case X86_64_NO_CLASS:
       // padding bytes.
@@ -1769,8 +1770,9 @@
 
   // Special handling for _Complex.
   if (llvm_x86_should_not_return_complex_in_memory(type)) {
-    ElementTypes.push_back(Type::getX86_FP80Ty(Context));
-    ElementTypes.push_back(Type::getX86_FP80Ty(Context));
+    // @LOCALMOD
+    ElementTypes.push_back(Type::getDoubleTy(Context));
+    ElementTypes.push_back(Type::getDoubleTy(Context));
     return StructType::get(Context, ElementTypes, STy->isPacked());
   } 
 
diff -r 037e5342ba86 gcc/config/i386/t-crtfm
--- a/gcc/config/i386/t-crtfm	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/i386/t-crtfm	Mon Jul 18 18:48:47 2011 -0700
@@ -1,4 +1,6 @@
-EXTRA_PARTS += crtfastmath.o
+# @LOCALMOD we have our own startup code so we do not use this
+#           furthermore, crtfastmath.c contains inline asm's
+#EXTRA_PARTS += crtfastmath.o
 
 $(T)crtfastmath.o: $(srcdir)/config/i386/crtfastmath.c $(GCC_PASSES)
 	$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -msse -c \
diff -r 037e5342ba86 gcc/config/i386/t-linux64
--- a/gcc/config/i386/t-linux64	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/i386/t-linux64	Mon Jul 18 18:48:47 2011 -0700
@@ -22,7 +22,7 @@
 LIBGCC = stmp-multilib
 INSTALL_LIBGCC = install-multilib
 
-EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o crtbeginS.o crtendS.o \
+EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o \
 		     crtbeginT.o crtfastmath.o
 
 # The pushl in CTOR initialization interferes with frame pointer elimination.
diff -r 037e5342ba86 gcc/config/i386/unix.h
--- a/gcc/config/i386/unix.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/i386/unix.h	Mon Jul 18 18:48:47 2011 -0700
@@ -65,6 +65,12 @@
 #define TARGET_SUBTARGET_DEFAULT \
 	(MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS)
 
+// @LOCALMOD-BEGIN: Added MASK_ALIGN_DOUBLE for X86-32.
+#undef TARGET_SUBTARGET32_DEFAULT
+#define TARGET_SUBTARGET32_DEFAULT \
+	(MASK_ALIGN_DOUBLE)
+// @LOCALMOD-END
+
 /* By default, 64-bit mode uses 128-bit long double.  */
 #undef TARGET_SUBTARGET64_DEFAULT
 #define TARGET_SUBTARGET64_DEFAULT \
diff -r 037e5342ba86 gcc/config/t-linux
--- a/gcc/config/t-linux	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/config/t-linux	Mon Jul 18 18:48:47 2011 -0700
@@ -1,13 +1,25 @@
 # Compile crtbeginS.o and crtendS.o with pic.
 CRTSTUFF_T_CFLAGS_S = $(CRTSTUFF_T_CFLAGS) -fPIC
 # Compile libgcc2.a with pic.
-TARGET_LIBGCC2_CFLAGS = -fPIC
+# TARGET_LIBGCC2_CFLAGS = -fPIC
 
 # Override t-slibgcc-elf-ver to export some libgcc symbols with
 # the symbol versions that glibc used.
 SHLIB_MAPFILES += $(srcdir)/config/libgcc-glibc.ver
 
 # Use unwind-dw2-fde-glibc
-LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-glibc.c \
-  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
-LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c
+# @LOCALMOD-START
+# pnacl uses this config since it is a linux flavor
+# but we do not want it to overwrite the default settings
+# for exception handling
+#
+#LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c
+#LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c
+# another setup to explore is that of nacl-gcc which is using a newer version
+# of gcc as well:
+#LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-glibc.c \
+   $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
+#LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c
+# @LOCALMOD-END
+
+
diff -r 037e5342ba86 gcc/crtstuff.c
--- a/gcc/crtstuff.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/crtstuff.c	Mon Jul 18 18:48:47 2011 -0700
@@ -51,6 +51,15 @@
 
    This file must be compiled with gcc.  */
 
+/* @LOCALMOD-START
+   Disable all crtstuff for pnacl which has its own startup code
+   Disabling this any other way proved tricky and would involve more changes.
+   Ideally this hack would be eliminated in a special (p)nacl-target, though
+   it is not clear whether this is at all possible.
+*/
+#if 0
+/* @LOCALMOD-END */
+
 /* Target machine header files require this define. */
 #define IN_LIBGCC2
 
@@ -688,3 +697,4 @@
 #else /* ! CRT_BEGIN && ! CRT_END */
 #error "One of CRT_BEGIN or CRT_END must be defined."
 #endif
+#endif /* @LOCALMOD-END */
diff -r 037e5342ba86 gcc/libgcc-memcpy.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gcc/libgcc-memcpy.c	Mon Jul 18 18:48:47 2011 -0700
@@ -0,0 +1,40 @@
+/* memcpy copy for libgcc.  */
+/* Copyright (C) 2010 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.  */
+
+#include <stddef.h>
+
+void *
+memcpy(void *dest, const void *src, size_t n)
+{
+  char *destp = dest;
+  const char *srcp = src;
+  while (n--)
+    *destp++ = *srcp++;
+  return dest;
+}
diff -r 037e5342ba86 gcc/libgcc2.c
--- a/gcc/libgcc2.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/libgcc2.c	Mon Jul 18 18:48:47 2011 -0700
@@ -42,6 +42,20 @@
 #endif
 /* APPLE LOCAL end libcc_kext */
 
+/* On NaCl we want to avoid libgcc -> libc dependencies, and signals are
+   not implemented. */
+
+#ifdef __native_client__
+/* This would be slightly cleaner:
+ *  #define abort() asm("llvm.trap")
+ * but we have trouble with the inliner and bitcode at this point
+ * and llvm transforms the zero dereference into a trap internally anyway.
+ * Note, that int, char, etc. are not available in this file
+ */
+
+#define abort() * (SItype*) 0 = 0
+#endif
+
 #ifdef HAVE_GAS_HIDDEN
 #define ATTRIBUTE_HIDDEN  __attribute__ ((__visibility__ ("hidden")))
 #else
@@ -2048,6 +2062,14 @@
 #endif
 
 
+/* @LOCALMOD-START
+   Since pnacl does not support self modifying code we don't want these
+   functions anyway - but if a need arises we should implement them in
+   src/untrusted/stubs/ analogous to setjmp/longjmp
+*/
+#if 0 
+/* @LOCALMOD-END */
+
 #ifdef L_clear_cache
 /* Clear part of an instruction cache.  */
 
@@ -2073,6 +2095,9 @@
 {}
 #endif /* ENABLE_EXECUTE_STACK */
 
+#endif /* @LOCALMOD */
+
+
 #endif /* L_enable_execute_stack */
 
 #ifdef L_trampoline
diff -r 037e5342ba86 gcc/llvm-backend.cpp
--- a/gcc/llvm-backend.cpp	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/llvm-backend.cpp	Mon Jul 18 18:48:47 2011 -0700
@@ -1894,6 +1894,15 @@
 /// llvm_emit_file_scope_asm - Emit the specified string as a file-scope inline
 /// asm block.
 void llvm_emit_file_scope_asm(const char *string) {
+  // @LOCALMOD-BEGIN
+  // TODO: we may need to check that this is actually ASM and not some
+  // metadata that is masquerading as asm.
+  // There has been discussion about file-scope asm being used as a
+  // mechanism for emitting other strings such as ARM build attributes.
+  // Not sure if there is a portable use case for this.
+  note_nonportable_llvm("About to emit module-level assembly into bitcode!\n");
+  note_nonportable_llvm(string);
+  // @LOCALMOD-END
   if (TheModule->getModuleInlineAsm().empty())
     TheModule->setModuleInlineAsm(string);
   else
@@ -1926,6 +1935,19 @@
   WriteTypeSymbolic(RO, (const Type*)LLVM, TheModule);
 }
 
+// @LOCALMOD-BEGIN
+/// note_nonportable_llvm - Note that we are about to emit non-portable
+/// bits into llvm bitcode. This may generate a warning, an error, or nothing,
+/// depending on flags.
+void note_nonportable_llvm(const char *mesg) {
+  if (warn_portable_llvm) {
+    warning(OPT_Wportable_llvm, mesg);
+  } else if (error_portable_llvm) {
+    error("%s", mesg);
+  }
+}
+// @LOCALMOD-END
+
 /// extractRegisterName - Get a register name given its decl. In 4.2 unlike 4.0
 /// these names have been run through set_user_assembler_name which means they
 /// may have a leading \1 at this point; compensate.
diff -r 037e5342ba86 gcc/llvm-convert.cpp
--- a/gcc/llvm-convert.cpp	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/llvm-convert.cpp	Mon Jul 18 18:48:47 2011 -0700
@@ -4348,6 +4348,10 @@
     return 0;   // Just don't copy something into DestLoc.
   }
 
+  // @LOCALMOD-BEGIN
+  note_nonportable_llvm("About to emit asm reg-copy into bitcode!\n");
+  // @LOCALMOD-END
+
   // Turn this into a 'tmp = call Ty asm "", "={reg}"()'.
   FunctionType *FTy = FunctionType::get(Ty, std::vector<const Type*>(),false);
 
@@ -4374,6 +4378,10 @@
     return 0;   // Just don't copy something into DestLoc.
   }
 
+  // @LOCALMOD-BEGIN
+  note_nonportable_llvm("About to emit asm reg-copy into bitcode!\n");
+  // @LOCALMOD-END
+
   std::vector<const Type*> ArgTys;
   ArgTys.push_back(Ty);
   FunctionType *FTy = FunctionType::get(Type::getVoidTy(Context), 
@@ -4403,6 +4411,10 @@
   if (ValidateRegisterVariable(decl))
     return;
 
+  // @LOCALMOD-BEGIN
+  note_nonportable_llvm("About to emit asm reg-copy into bitcode!\n");
+  // @LOCALMOD-END
+
   // Turn this into a 'call void asm sideeffect "", "{reg}"(Ty %RHS)'.
   std::vector<const Type*> ArgTys;
   const Type* Ty = ConvertType(TREE_TYPE(decl));
@@ -4787,6 +4799,18 @@
 }
 
 Value *TreeToLLVM::EmitASM_EXPR(tree exp) {
+
+  // @LOCALMOD-BEGIN
+  // TODO: refine check if asm is portable (e.g., with some mechanism we
+  // add in the future), and don't warn in that case!
+  // This already skips warnings for asm that maps to portable llvm intrinsics.
+
+  // This output is very verbose and hard to read:
+  // debug_tree(exp);
+  // so instead we print the actual assembly code further down 
+  note_nonportable_llvm("About to emit asm into bitcode!\n");
+  // @LOCALMOD-END
+
   unsigned NumInputs = list_length(ASM_INPUTS(exp));
   unsigned NumOutputs = list_length(ASM_OUTPUTS(exp));
   unsigned NumInOut = 0;
@@ -5169,6 +5193,9 @@
     return 0;
   }
 
+  /* @LOCALMOD-START */
+  note_nonportable_llvm(NewAsmStr.c_str());
+  /* @LOCALMOD-END */
   Value *Asm = InlineAsm::get(FTy, NewAsmStr, ConstraintStr,
                               HasSideEffects, ASM_ASM_BLOCK(exp));
   CallInst *CV = Builder.CreateCall(Asm, CallOps.begin(), CallOps.end(),
@@ -5194,12 +5221,23 @@
     }
   }
 
+
+/* @LOCALMOD we do not want this for pnacl 
+ * TODO: investigate:
+ * It seemed dangerous to me to invoke anything that smells
+ * like backend from our supposedly architecture agnostic frontend.
+ * In the pnacl case it would only apply arm specific transformations.
+ *
+ * Hopefully, this whole issue is moot as we never have anything to
+ * convert at this point
+ */
+
   // Give the backend a chance to upgrade the inline asm to LLVM code.  This
   // handles some common cases that LLVM has intrinsics for, e.g. x86 bswap ->
   // llvm.bswap.
   if (const TargetLowering *TLI = TheTarget->getTargetLowering())
     TLI->ExpandInlineAsm(CV);
-
+  
   if (NumChoices>1)
     FreeConstTupleStrings(ReplacementStrings, NumInputs+NumOutputs);
   return 0;
@@ -5479,6 +5517,7 @@
   // Varargs builtins.
   case BUILT_IN_VA_START:
   case BUILT_IN_STDARG_START:   return EmitBuiltinVAStart(exp);
+  case BUILT_IN_VA_ARG:         return EmitBuiltinVAArg(exp, Result);
   case BUILT_IN_VA_END:         return EmitBuiltinVAEnd(exp);
   case BUILT_IN_VA_COPY:        return EmitBuiltinVACopy(exp);
   case BUILT_IN_CONSTANT_P:     return EmitBuiltinConstantP(exp, Result);
@@ -6606,8 +6645,22 @@
   if (!validate_arglist(TREE_OPERAND(exp, 1), VOID_TYPE))
     return false;
 
+  /*
+   * @LOCALMOD-START
+   * A really gross hack - this is never used for ARM and causes
+   * an ICE/segfault (likely because ARG_POINTER_CFA_OFFSET is 4 on arm).
+   * But we want to use this frontend for EmitBuiltinDwarfCFA() debugging
+   * on x86.
+   * ARG_POINTER_CFA_OFFSET(exp) is always zero for x86, c.f.
+   * llvm-gcc-4.2/gcc/config/i386/i386.h
+   */
+#if 1
+  int cfa_offset = 0;
+#else
   int cfa_offset = ARG_POINTER_CFA_OFFSET(exp);
-
+#endif
+  /* @LOCALMOD-END */
+     
   // FIXME: is i32 always enough here?
   Result = Builder.CreateCall(Intrinsic::getDeclaration(TheModule,
                                                         Intrinsic::eh_dwarf_cfa),
@@ -6683,6 +6736,11 @@
 }
 
 bool TreeToLLVM::EmitBuiltinInitDwarfRegSizes(tree exp, Value *&/*Result*/) {
+  /*
+   * @LOCALMOD - carefully revisit this for ARM
+   * Note, this built-in is only used by  llvm-gcc-4.2/gcc/unwind-dw2.c
+   *  __builtin_init_dwarf_reg_size_table
+   */
 #ifdef DWARF2_UNWIND_INFO
   unsigned int i;
   bool wrote_return_column = false;
@@ -6831,6 +6889,14 @@
   return true;
 }
 
+bool TreeToLLVM::EmitBuiltinVAArg(tree exp, Value *&Result) {
+  // Emit an llvm.va_arg opcode for the call to __builtin_va_arg.
+  Result = Builder.CreateVAArg(
+      Emit(TREE_VALUE(TREE_OPERAND(exp, 1)), 0),
+      ConvertType(TREE_TYPE(exp))); // (the type info was faked earlier)
+  return true;
+}
+
 bool TreeToLLVM::EmitBuiltinVACopy(tree exp) {
   tree Arg1T = TREE_VALUE(TREE_OPERAND(exp, 1));
   tree Arg2T = TREE_VALUE(TREE_CHAIN(TREE_OPERAND(exp, 1)));
diff -r 037e5342ba86 gcc/llvm-internal.h
--- a/gcc/llvm-internal.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/llvm-internal.h	Mon Jul 18 18:48:47 2011 -0700
@@ -570,6 +570,7 @@
   bool EmitBuiltinExtendPointer(tree_node *exp, Value *&Result);
   bool EmitBuiltinVAStart(tree_node *exp);
   bool EmitBuiltinVAEnd(tree_node *exp);
+  bool EmitBuiltinVAArg(tree_node *exp, Value *&Result);
   bool EmitBuiltinVACopy(tree_node *exp);
   bool EmitBuiltinMemCopy(tree_node *exp, Value *&Result,
                           bool isMemMove, bool SizeCheck);
diff -r 037e5342ba86 gcc/llvm.h
--- a/gcc/llvm.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/llvm.h	Mon Jul 18 18:48:47 2011 -0700
@@ -116,6 +116,14 @@
  * to the more concrete type new_type.
  */
 void refine_type_to (union tree_node*, union tree_node*);
+
+/* @LOCALMOD-BEGIN */
+/* Note that we are about to emit non-portable bits into llvm bitcode.
+ * This may generate a warning, an error, or nothing, depending on flags.
+ */
+void note_nonportable_llvm(const char *mesg);
+/* @LOCALMOD-END */
+
 #endif /* ENABLE_LLVM */
 
 #endif
diff -r 037e5342ba86 gcc/longlong.h
--- a/gcc/longlong.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/longlong.h	Mon Jul 18 18:48:47 2011 -0700
@@ -97,6 +97,15 @@
    (E.g. WE32100, IBM360.)  */
 
 /* LLVM LOCAL begin */
+/* @LOCALMOD-START
+ * disable inline assembly for now and fall back to the generic versions
+ * the LLVM backend will likely generate inline code for these anyway
+ */
+#if !defined (NO_ASM)
+#define NO_ASM
+#endif
+/* @LOCALMOD-END */
+
 #if defined (__GNUC__) && !defined (NO_ASM) && (!defined (ENABLE_LLVM) || !defined (__llvm__))
 /* LLVM LOCAL end */
 
diff -r 037e5342ba86 gcc/mklibgcc.in
--- a/gcc/mklibgcc.in	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/mklibgcc.in	Mon Jul 18 18:48:47 2011 -0700
@@ -218,7 +218,9 @@
   shlib_slibdir_qual=
   libgcc_a=$dir/libgcc.a
   libgcov_a=$dir/libgcov.a
-  libgcc_eh_a=
+  # @LOCALMOD 
+  # always enable creation of libgcc_eh.a
+  libgcc_eh_a=$dir/libgcc_eh.a
   libgcc_s_so=
   libunwind_a=
   libunwind_so=
@@ -897,11 +899,16 @@
   echo '	chmod 644'  ${ldir}/libgcov.a
   echo '	$(RANLIB_FOR_TARGET)' ${ldir}/libgcov.a
 
-  if [ "$SHLIB_LINK" ]; then
+  # @LOCALMOD
+  # move installation of libgcc_eh out of the SHLIB_LINK condition
+  # if [ "$SHLIB_LINK" ]; then
     echo '	$(INSTALL_DATA)' ${dir}/libgcc_eh.a ${ldir}/
     echo '	chmod 644'  ${ldir}/libgcc_eh.a
     echo '	$(RANLIB_FOR_TARGET)' ${ldir}/libgcc_eh.a
 
+  # @LOCALMOD
+  if [ "$SHLIB_LINK" ]; then
+
     shlib_slibdir_qual=
     os_multilib_dir=`$GCC_FOR_TARGET $flags --print-multi-os-directory`
     if [ "$os_multilib_dir" != . ]; then
diff -r 037e5342ba86 gcc/tree.c
--- a/gcc/tree.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/tree.c	Mon Jul 18 18:48:47 2011 -0700
@@ -6743,7 +6743,21 @@
   layout_type (complex_long_double_type_node);
 
   {
-    tree t = targetm.build_builtin_va_list ();
+    /* @LOCALMOD-BEGIN */
+    tree t;
+    if (flag_use_llvm_va_arg)
+      {
+        /* If not expanding va_arg, make va_list large enough
+           so that the generated bitcode will work on all platforms.
+           (e.g., X86-64 needs exactly 24-bytes for va_list) */
+
+        t = build_array_type (
+                long_long_unsigned_type_node,
+                build_index_type (build_int_cst (NULL_TREE, 3-1)));
+      }
+    else
+        t = targetm.build_builtin_va_list ();
+    /* @LOCALMOD-END */
 
     /* Many back-ends define record types without setting TYPE_NAME.
        If we copied the record type here, we'd keep the original
diff -r 037e5342ba86 gcc/tree.h
--- a/gcc/tree.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/tree.h	Mon Jul 18 18:48:47 2011 -0700
@@ -4591,6 +4591,7 @@
 extern tree strip_float_extensions (tree);
 extern tree c_strlen (tree, int);
 extern tree std_gimplify_va_arg_expr (tree, tree, tree *, tree *);
+extern tree llvm_gimplify_va_arg_expr (tree, tree, tree *, tree *);
 extern tree build_va_arg_indirect_ref (tree);
 tree build_string_literal (int, const char *);
 
diff -r 037e5342ba86 gcc/unwind-c.c
--- a/gcc/unwind-c.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/unwind-c.c	Mon Jul 18 18:48:47 2011 -0700
@@ -32,6 +32,20 @@
 #include "tconfig.h"
 #include "tsystem.h"
 #include "unwind.h"
+
+
+/* On NaCl we want to avoid libgcc -> libc dependencies, and signals are
+   not implemented. */
+#ifdef __native_client__
+/* This would be slightly cleaner:
+ *  #define abort() asm("llvm.trap")
+ * but we have trouble with the inliner and bitcode at this point
+ * and llvm transforms the zero dereference into a trap internally anyway.
+ */
+
+#define abort() * (int*) 0 = 0
+#endif
+
 #define NO_SIZE_OF_ENCODED_VALUE
 #include "unwind-pe.h"
 
@@ -82,6 +96,8 @@
 }
 
 #ifdef __ARM_EABI_UNWINDER__
+#error "PNACL does not want __ARM_EABI_UNWINDER__ to be defined"
+
 /* ARM EABI personality routines must also unwind the stack.  */
 #define CONTINUE_UNWINDING \
   do								\
diff -r 037e5342ba86 gcc/unwind-dw2-fde.c
--- a/gcc/unwind-dw2-fde.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/unwind-dw2-fde.c	Mon Jul 18 18:48:47 2011 -0700
@@ -258,6 +258,15 @@
     }
 }
 
+/* @LOCALMOD-START */
+/* avoid deps on libc */
+static int mystrlen(const char* cp) {
+  int count = 0;
+  while (*cp++) ++count;
+  return count;
+}
+/* @LOCALMOD-END */
+
 /* Return the FDE pointer encoding from the CIE.  */
 /* ??? This is a subset of extract_cie_info from unwind-dw2.c.  */
 
@@ -273,7 +282,8 @@
   if (aug[0] != 'z')
     return DW_EH_PE_absptr;
 
-  p = aug + strlen ((const char *)aug) + 1; /* Skip the augmentation string.  */
+  // @LOCALMOD
+  p = aug + mystrlen ((const char *)aug) + 1; /* Skip the augmentation string.  */
   p = read_uleb128 (p, &utmp);		/* Skip code alignment.  */
   p = read_sleb128 (p, &stmp);		/* Skip data alignment.  */
   if (cie->version == 1)		/* Skip return address column.  */
@@ -578,6 +588,13 @@
       fde_split (ob, fde_compare, accu->linear, accu->erratic);
       gcc_assert (accu->linear->count + accu->erratic->count == count);
       frame_heapsort (ob, fde_compare, accu->erratic);
+      // @LOCALMOD-BEGIN
+      // Sorting just the erratic and then merging with the linear,
+      // can still leave it unsorted sometimes. Sort the linear as well!
+      // Triggered by:
+      // http://code.google.com/p/nativeclient/issues/detail?id=1106
+      frame_heapsort (ob, fde_compare, accu->linear);
+      // @LOCALMOD-END
       fde_merge (ob, fde_compare, accu->linear, accu->erratic);
       free (accu->erratic);
     }
diff -r 037e5342ba86 gcc/unwind-dw2.c
--- a/gcc/unwind-dw2.c	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/unwind-dw2.c	Mon Jul 18 18:48:47 2011 -0700
@@ -60,6 +60,23 @@
 #define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)
 #endif
 
+/* @LOCALMOD-START */
+/* avoid deps on libc - note: regions are extremely small and do not overlap */
+static void mybzero(char* cp, int len) {
+  for(;len > 0; --len) *cp++ = 0;
+}
+
+static int mystrlen(const char* cp) {
+  int count = 0;
+  while (*cp++) ++count;
+  return count;
+}
+
+static void mymemcpy(char* dst, const char* src, int len) {
+  for(;len > 0; --len) *dst++ = *src++;
+}
+/* @LOCALMOD-END */
+
 /* This is the register and unwind state for a particular frame.  This
    provides the information necessary to unwind up past a frame and return
    to its caller.  */
@@ -82,6 +99,34 @@
   char by_value[DWARF_FRAME_REGISTERS+1];
 };
 
+/* @LOCALMOD-START */
+#if 0
+void DUMP_CONTEXT(struct _Unwind_Context* c) {
+  int i;
+  printf("--------  _Unwind_Context: %p, cfa: %p,  ra: %p, lsda: %p\n",
+         c, c->cfa, c->ra, c->lsda);
+  for (i = 0; i < DWARF_FRAME_REGISTERS+1; i++) {
+    printf("reg %2d: %p (by val %d)", i, c->reg[i], c->by_value[i]);
+    if  (!c->by_value[i] && c->reg[i] != 0) { 
+      printf(" -> %p", *(void**)c->reg[i]);
+    }
+    printf(" \n");
+  }
+}
+
+void DUMP_FS(_Unwind_FrameState* fs) {
+  int i;
+  printf("--------  _Unwind_FrameState: %p, pc: %p\n", fs, fs->pc);
+  printf("cfa offset:%d, reg: %d, how: %d\n", 
+	 fs->cfa_offset, fs->cfa_reg, fs->cfa_how);
+  for (i = 0; i < DWARF_FRAME_REGISTERS+1; i++) {
+    printf("reg %2d, loc:%d, how:%d\n",
+           i, fs->regs.reg[i].loc.reg, fs->regs.reg[i].how);
+  }
+}
+#endif
+/* @LOCALMOD-END */
+
 /* Byte size of every register managed by these routines.  */
 static unsigned char dwarf_reg_size_table[DWARF_FRAME_REGISTERS+1];
 
@@ -163,12 +208,10 @@
   if (index == DWARF_ZERO_REG)
     return 0;
 #endif
-
   index = DWARF_REG_TO_UNWIND_COLUMN (index);
   gcc_assert (index < (int) sizeof(dwarf_reg_size_table));
   size = dwarf_reg_size_table[index];
   ptr = context->reg[index];
-
   if (_Unwind_IsExtendedContext (context) && context->by_value[index])
     return (_Unwind_Word) (_Unwind_Internal_Ptr) ptr;
 
@@ -225,6 +268,68 @@
     }
 }
 
+/* @LOCALMOD-START */
+/*
+ * new ABI functions to support a platform independent version
+ * of libstdc++
+ * NOTE: this is only inline because we follow the model of the other
+ * functions - that those are marked 'inline' seems questionable
+ *
+ */
+
+/* abstract away __builtin_eh_return_data_regno(0) 
+ * this needs to be better researched and documented 
+ * the index is likely influenced by  DWARF_FRAME_REGNUM(REG) and
+ * EH_RETURN_DATA_REGNO
+ * c.f.: expand_builtin_eh_return_data_regno()
+ *
+ * NOTE: when gcc restores registers it relies on epilog code
+ * of the function containing the call to __builtin_eh_return
+ * (usually via the uw_install_context(CURRENT, TARGET) macro).
+ *
+ * If the epilog code does NOT restore the two result regs we
+ * are toast - there is run-time check which sadly
+ * results in a silent abort built into uw_install_context_1()
+ * look for the first gcc_assert
+ */
+ 
+inline void
+_Unwind_PNaClSetResult0 (struct _Unwind_Context *context, _Unwind_Word val) {
+#if defined(__x86_64__)
+  _Unwind_SetGR(context, 0, val);
+  return;
+#elif defined(__i386__)
+  _Unwind_SetGR(context, 0, val);
+  return;
+#elif defined(__arm__)
+  _Unwind_SetGR(context, 4, val);  /* first callee saved reg on ARM */
+  return;
+#else
+  #error "unknown platform"
+  abort();
+#endif
+
+}
+
+/* abstract away __builtin_eh_return_data_regno(1) */
+inline  void
+_Unwind_PNaClSetResult1 (struct _Unwind_Context *context, _Unwind_Word val) {
+#if defined(__x86_64__)
+  _Unwind_SetGR(context, 1, val);
+  return;
+#elif defined(__i386__)
+  _Unwind_SetGR(context, 2, val);
+  return;
+#elif defined(__arm__)
+  _Unwind_SetGR(context, 5, val);  /* second callee saved reg on ARM */
+  return;
+#else
+  #error "unknown platform"
+  abort();
+#endif
+}
+/* @LOCALMOD-END */
+
 /* Get the pointer to a register INDEX as saved in CONTEXT.  */
 
 static inline void *
@@ -347,7 +452,7 @@
 		  _Unwind_FrameState *fs)
 {
   const unsigned char *aug = cie->augmentation;
-  const unsigned char *p = aug + strlen ((const char *)aug) + 1;
+  const unsigned char *p = aug + mystrlen ((const char *)aug) + 1;
   const unsigned char *ret = NULL;
   _Unwind_Word utmp;
 
@@ -1096,7 +1201,7 @@
   const struct dwarf_cie *cie;
   const unsigned char *aug, *insn, *end;
 
-  memset (fs, 0, sizeof (*fs));
+  mybzero (fs, sizeof (*fs));   /* @LOCALMOD */
   context->args_size = 0;
   context->lsda = 0;
 
@@ -1127,6 +1232,7 @@
 
   /* First decode all the insns in the CIE.  */
   end = (unsigned char *) next_fde ((struct dwarf_fde *) cie);
+
   execute_cfa_program (insn, end, context, fs);
 
   /* Locate augmentation for the fde.  */
@@ -1181,7 +1287,7 @@
   _Unwind_FrameState fs;
   int reg;
 
-  memset (&context, 0, sizeof (struct _Unwind_Context));
+  mybzero (&context, sizeof (struct _Unwind_Context));   /* @LOCALMOD */
   context.flags = EXTENDED_CONTEXT_BIT;
   context.ra = pc_target + 1;
 
@@ -1363,7 +1469,6 @@
 uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)
 {
   uw_update_context_1 (context, fs);
-
   /* Compute the return address now, since the return address column
      can change from frame to frame.  */
   context->ra = __builtin_extract_return_addr
@@ -1405,7 +1510,7 @@
   _Unwind_SpTmp sp_slot;
   _Unwind_Reason_Code code;
 
-  memset (context, 0, sizeof (struct _Unwind_Context));
+  mybzero (context, sizeof (struct _Unwind_Context));  /* @LOCALMOD */
   context->ra = ra;
   context->flags = EXTENDED_CONTEXT_BIT;
 
@@ -1452,6 +1557,23 @@
     }									 \
   while (0)
 
+
+/* LOCAMOD-START */
+/* Copy some register state from the target context to the current context.
+   The target context is roughly the saved register area of the function
+   called by the function we want to jump back into.
+   We copy this information into the saved register area of the currently
+   executing function F.
+   This is counter intuitive but when the epilog code of F is run we
+   get the effect of a mini longjmp.
+   This longjmp has two short commings, though:
+   * it does not set the pc
+   * it may not set the sp
+   This is compensated by the following built-in:
+   __builtin_eh_return (offset, handler);	
+ */
+/* LOCAMOD-END */
+ 
 static long
 uw_install_context_1 (struct _Unwind_Context *current,
 		      struct _Unwind_Context *target)
@@ -1477,17 +1599,19 @@
 	  if (dwarf_reg_size_table[i] == sizeof (_Unwind_Word))
 	    {
 	      w = (_Unwind_Internal_Ptr) t;
-	      memcpy (c, &w, sizeof (_Unwind_Word));
+	      mymemcpy (c, &w, sizeof (_Unwind_Word)); /* @LOCALMOD */
+
 	    }
 	  else
 	    {
 	      gcc_assert (dwarf_reg_size_table[i] == sizeof (_Unwind_Ptr));
 	      p = (_Unwind_Internal_Ptr) t;
-	      memcpy (c, &p, sizeof (_Unwind_Ptr));
+	      mymemcpy (c, &p, sizeof (_Unwind_Ptr)); /* @LOCALMOD */
+
 	    }
 	}
       else if (t && c && t != c)
-	memcpy (c, t, dwarf_reg_size_table[i]);
+	mymemcpy (c, t, dwarf_reg_size_table[i]); /* @LOCALMOD */
     }
 
   /* If the current frame doesn't have a saved stack pointer, then we
@@ -1534,7 +1658,13 @@
 alias (_Unwind_Resume);
 alias (_Unwind_Resume_or_Rethrow);
 alias (_Unwind_SetGR);
+/* @LOCALMOD-START */
+alias (_Unwind_PNaClSetResult0);
+alias (_Unwind_PNaClSetResult1);
+/* @LOCALMOD-END */
 alias (_Unwind_SetIP);
 #endif
 
 #endif /* !USING_SJLJ_EXCEPTIONS */
+
+/* @LOCALMOD-END */
diff -r 037e5342ba86 gcc/unwind-generic.h
--- a/gcc/unwind-generic.h	Thu Jan 27 21:38:44 2011 +0000
+++ b/gcc/unwind-generic.h	Mon Jul 18 18:48:47 2011 -0700
@@ -92,6 +92,17 @@
   _Unwind_Word private_1;
   _Unwind_Word private_2;
 
+  // @LOCALMOD-START
+  // some extra space to help with libgcc_eh on x86-64 which thinks this
+  // structure is bigger than what the bitcode thinks and hence
+  // when private_1/private_2 are written to they might write over
+  // the end of the struct into the exception which the bitcode places
+  // immediately after it
+  // c.f. http://code.google.com/p/nativeclient/issues/detail?id=1107
+  // An array of size 4 would likely suffice - 8 plays it safe
+  int _do_not_use[8];
+  // @LOCALMOD-END
+
   /* @@@ The IA-64 ABI says that this structure must be double-word aligned.
      Taking that literally does not make much sense generically.  Instead we
      provide the maximum alignment required by any type for the machine.  */
@@ -158,6 +169,12 @@
 extern _Unwind_Ptr _Unwind_GetIPInfo (struct _Unwind_Context *, int *);
 extern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);
 
+
+/* @LOCALMOD-START */
+extern void _Unwind_PNaClSetResult0 (struct _Unwind_Context *, _Unwind_Word);
+extern void _Unwind_PNaClSetResult1 (struct _Unwind_Context *, _Unwind_Word);
+/* @LOCALMOD-END */
+
 /* @@@ Retrieve the CFA of the given context.  */
 extern _Unwind_Word _Unwind_GetCFA (struct _Unwind_Context *);
 
diff -r 037e5342ba86 libstdc++-v3/libsupc++/eh_arm.cc
--- a/libstdc++-v3/libsupc++/eh_arm.cc	Thu Jan 27 21:38:44 2011 +0000
+++ b/libstdc++-v3/libsupc++/eh_arm.cc	Mon Jul 18 18:48:47 2011 -0700
@@ -30,6 +30,7 @@
 #include <cxxabi.h>
 #include "unwind-cxx.h"
 
+
 #ifdef __ARM_EABI_UNWINDER__
 
 using namespace __cxxabiv1;
@@ -166,5 +167,4 @@
 "	ldmfd\tsp!, {r1, r2, r3, r4}\n"
 "	bl\t_Unwind_Resume @ Never returns\n");
 #endif
-
 #endif
diff -r 037e5342ba86 libstdc++-v3/libsupc++/eh_personality.cc
--- a/libstdc++-v3/libsupc++/eh_personality.cc	Thu Jan 27 21:38:44 2011 +0000
+++ b/libstdc++-v3/libsupc++/eh_personality.cc	Mon Jul 18 18:48:47 2011 -0700
@@ -405,6 +405,7 @@
   // virtual IP register point at the UCB.
   ip = (_Unwind_Ptr) ue_header;
   _Unwind_SetGR(context, 12, ip);
+
 #else
   __cxa_exception* xh = __get_exception_header_from_ue(ue_header);
 
@@ -677,11 +678,13 @@
 
   /* For targets with pointers smaller than the word size, we must extend the
      pointer, and this extension is target dependent.  */
-  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),
-		 __builtin_extend_pointer (ue_header));
-  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),
-		 handler_switch_value);
+
+  /* @LOCALMOD-START */
+  _Unwind_PNaClSetResult0(context, __builtin_extend_pointer (ue_header));
+  _Unwind_PNaClSetResult1(context, handler_switch_value);
+  /* @LOCALMOD-END */
   _Unwind_SetIP (context, landing_pad);
+
 #ifdef __ARM_EABI_UNWINDER__
   if (found_type == found_cleanup)
     __cxa_begin_cleanup(ue_header);
diff -r 037e5342ba86 libstdc++-v3/libsupc++/eh_throw.cc
--- a/libstdc++-v3/libsupc++/eh_throw.cc	Thu Jan 27 21:38:44 2011 +0000
+++ b/libstdc++-v3/libsupc++/eh_throw.cc	Mon Jul 18 18:48:47 2011 -0700
@@ -52,6 +52,7 @@
   __cxa_free_exception (header + 1);
 }
 
+extern "C" void abort(void);
 
 extern "C" void
 __cxxabiv1::__cxa_throw (void *obj, std::type_info *tinfo, 
